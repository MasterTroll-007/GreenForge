package autofix

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/greencode/greenforge/internal/cicd"
	"github.com/greencode/greenforge/internal/config"
)

// Fixer attempts to automatically fix pipeline failures.
type Fixer struct {
	cfg     *config.Config
	clients []cicd.Client
}

// FixRequest contains everything needed to attempt a fix.
type FixRequest struct {
	Pipeline  cicd.Pipeline
	Client    cicd.Client
	AutoMerge bool
}

// FixResult describes the outcome of a fix attempt.
type FixResult struct {
	Success     bool   `json:"success"`
	PRID        int    `json:"pr_id,omitempty"`
	PRURL       string `json:"pr_url,omitempty"`
	Description string `json:"description"`
	Branch      string `json:"branch"`
}

// NewFixer creates an auto-fix engine.
func NewFixer(cfg *config.Config, clients []cicd.Client) *Fixer {
	return &Fixer{
		cfg:     cfg,
		clients: clients,
	}
}

// Fix analyzes a pipeline failure and attempts to create a fix PR.
func (f *Fixer) Fix(ctx context.Context, req FixRequest) (*FixResult, error) {
	p := req.Pipeline

	// Step 1: Analyze the failure
	analysis := AnalyzeFailure(p)
	log.Printf("Auto-fix analysis for %s/%s: category=%s confidence=%.1f canAutoFix=%v",
		p.Project, p.Branch, analysis.Category, analysis.Confidence, analysis.CanAutoFix)

	if !analysis.CanAutoFix {
		return nil, fmt.Errorf("failure type '%s' cannot be auto-fixed: %s", analysis.Category, analysis.RootCause)
	}

	if analysis.Confidence < 0.5 {
		return nil, fmt.Errorf("confidence too low (%.1f) for auto-fix: %s", analysis.Confidence, analysis.RootCause)
	}

	// Step 2: Generate fix (this would use the AI agent in production)
	fixBranch := fmt.Sprintf("fix/%s-%s-%s", p.Branch, analysis.Category, time.Now().Format("20060102-1504"))

	// Step 3: Create PR via CI/CD client
	description := fmt.Sprintf(`## Auto-fix by GreenForge

**Pipeline:** %s (ID: %s)
**Branch:** %s
**Failure category:** %s
**Root cause:** %s
**Suggestion:** %s
**Confidence:** %.0f%%

---
This PR was automatically generated by GreenForge Pipeline Watcher.
`, p.Project, p.ID, p.Branch, analysis.Category, analysis.RootCause, analysis.Suggestion, analysis.Confidence*100)

	pr, err := req.Client.CreatePR(ctx, cicd.CreatePRRequest{
		Project:      p.Project,
		Title:        fmt.Sprintf("[GreenForge Auto-fix] %s: %s", analysis.Category, truncate(analysis.RootCause, 60)),
		Description:  description,
		SourceBranch: fixBranch,
		TargetBranch: p.Branch,
		Labels:       []string{"auto-fix", "greenforge"},
		AutoMerge:    req.AutoMerge,
	})
	if err != nil {
		return nil, fmt.Errorf("creating fix PR: %w", err)
	}

	return &FixResult{
		Success:     true,
		PRID:        pr.ID,
		PRURL:       pr.URL,
		Description: analysis.RootCause,
		Branch:      fixBranch,
	}, nil
}

// FixManual is called when user explicitly requests a fix for a specific pipeline.
func (f *Fixer) FixManual(ctx context.Context, project, pipelineID string) (*FixResult, error) {
	// Find the right client for this project
	for _, client := range f.clients {
		if !client.Available() {
			continue
		}

		pipelines, err := client.Pipelines(ctx, cicd.PipelineQuery{
			Project: project,
			Limit:   50,
		})
		if err != nil {
			continue
		}

		for _, p := range pipelines {
			if p.ID == pipelineID {
				return f.Fix(ctx, FixRequest{
					Pipeline:  p,
					Client:    client,
					AutoMerge: false,
				})
			}
		}
	}

	return nil, fmt.Errorf("pipeline %s not found in project %s", pipelineID, project)
}
